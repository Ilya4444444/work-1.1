1. Сортировка выбором
 
Определение: Этот метод упорядочивает массив, циклически находя наименьший элемент в необработанной части и ставя его в начало этой части.

Как работает: Внешний цикл for (int i = 0; ...) проходит по массиву. Его задача — поставить правильный элемент на позицию i. Внутренний цикл for (int j = i+1; ...) ищет в оставшейся части массива индекс самого маленького элемента (minIndex). После цикла команда swap(arr[i], arr[minIndex]) меняет местами текущий элемент и найденный минимум.

Пример:

Исходный массив: [64, 25, 12, 22, 11]
Результат: [11, 12, 22, 25, 64]

Сложность: Временная сложность всегда составляет O(n²), так как алгоритм выполняет два вложенных цикла, проходя по массиву примерно n*(n-1)/2 раз, независимо от исходного порядка данных.

2. Сортировка обменом

Определение: Простой алгоритм, который многократно "проталкивает" самые большие элементы в конец массива, попарно сравнивая и обменивая соседние элементы, если они расположены в неверном порядке.

Как работает: Алгоритм совершает несколько проходов по массиву. На каждом проходе он последовательно сравнивает пары соседних элементов. Если левый элемент больше правого, они меняются местами. Этот процесс повторяется до тех пор, пока массив не будет полностью отсортирован.

Пример:

Исходный массив: [5, 1, 4, 2, 8]
Результат: [1, 2, 4, 5, 8]

Сложность: Худший случай O(n²) возникает, когда массив отсортирован в обратном порядке. Лучший случай O(n) — когда массив уже отсортирован, и алгоритму требуется всего один проход без обменов.

3. Сортировка вставками

Определение: Алгоритм, который строит финальный отсортированный массив по одному элементу за раз. Он эффективно вставляет каждый новый элемент в правильную позицию внутри уже отсортированной части.

Как работает: Внешний цикл for (int i = 1; ...) проходит по всем элементам, начиная со второго. Переменная int key = arr[i] запоминает текущий элемент, который нужно "вставить" в отсортированную часть. Внутренний цикл while (j >= 0 && arr[j] > key) сдвигает элементы отсортированной части вправо, пока не найдется позиция для key. Переменная j начинается с i-1 и уменьшается, пока не встретит элемент меньше key или начало массива. Когда позиция найдена, команда arr[j + 1] = key вставляет сохраненное значение key на правильное место в отсортированной части массива.

Пример:

Исходный массив: [9, 5, 1, 4, 3]
Результат: [1, 3, 4, 5, 9]

Сложность: Сложность O(n²) в худшем случае (обратно отсортированный массив), но O(n) в лучшем случае (уже отсортированный массив), что делает его эффективным для небольших или почти упорядоченных наборов данных.

4. Сортировка слиянием

Определение: Эффективный алгоритм, построенный на принципе "разделяй и властвуй". Он рекурсивно разбивает массив на две половины до тех пор, пока не останутся подмассивы из одного элемента, а затем объединяет их в упорядоченном виде.

Как работает: Функция mergeSort рекурсивно разделяет массив. Строка int mid = left + (right - left) / 2 находит середину текущего отрезка, затем mergeSort(arr, left, mid) и mergeSort(arr, mid + 1, right) рекурсивно сортируют левую и правую половины. Базовый случай if (left >= right) return останавливает рекурсию, когда отрезок содержит 1 элемент. Функция merge объединяет два отсортированных отрезка. Сначала создаются временные векторы leftArr и rightArr для левой и правой половин. Затем цикл while (i < leftArr.size() && j < rightArr.size()) попеременно берет меньший элемент из двух массивов и записывает его в основной массив. Два последних цикла while дописывают оставшиеся элементы из того массива, который не был полностью обработан.

Пример:

Исходный массив: [6, 5, 3, 1, 8, 7, 2, 4]
Результат: [1, 2, 3, 4, 5, 6, 7, 8]

Сложность: Алгоритм всегда имеет сложность O(n log n), так как массив делится пополам (log n раз), а на каждом уровне слияния обрабатываются все n элементов.

5. Сортировка Шелла

Определение: Усовершенствованный вариант сортировки вставками, который сортирует элементы, расположенные далеко друг от друга, на начальных этапах, постепенно уменьшая разрыв между сравниваемыми элементами.

Как работает: Вместо сравнения соседних элементов, алгоритм сравнивает элементы, отстоящие друг от друга на некотором расстоянии (шаге). Это расстояние постепенно уменьшается до единицы. На последнем проходе выполняется обычная сортировка вставками, но благодаря предыдущим проходам данные уже почти упорядочены.

Пример:

Исходный массив: [35, 12, 29, 15, 42, 8]
Результат: [8, 12, 15, 29, 35, 42]

Сложность: Сложность сильно зависит от выбранной последовательности шагов. В среднем около O(n log n), в худшем случае — O(n²).

6. Быстрая сортировка

Определение: Еще один алгоритм типа "разделяй и властвуй", который выбирает "опорный" элемент и перераспределяет другие элементы вокруг него: меньшие помещаются слева, большие — справа.

Как работает: Функция partition выбирает опорный элемент pivot = arr[high] (последний элемент). Переменная i = (low - 1) отслеживает позицию, где заканчиваются элементы меньше опорного. Цикл for (int j = low; ...) проходит по всем элементам, и если arr[j] < pivot, то увеличивает i и меняет местами arr[i] и arr[j]. В конце swap(arr[i + 1], arr[high]) ставит опорный элемент на правильную позицию между двумя частями. Функция quickSort рекурсивно вызывает себя: quickSort(arr, low, pi - 1) для левой части (элементы меньше опорного) и quickSort(arr, pi + 1, high) для правой части (элементы больше опорного). Условие if (low < high) обеспечивает выход из рекурсии, когда отрезок содержит 0 или 1 элемент.

Пример:

Исходный массив: [10, 7, 8, 9, 1, 5]
Результат: [1, 5, 7, 8, 9, 10]

Сложность: В среднем O(n log n). Худший случай O(n²) может произойти при неудачном выборе опорного элемента (например, всегда максимального или минимального).

7. Пирамидальная сортировка

Определение: Алгоритм, который использует структуру данных "двочная куча" (бинарная куча). Он строит max-кучу из массива, где самый большой элемент находится в корне, и затем последовательно извлекает его, перестраивая кучу.

Как работает: Функция heapify поддерживает свойство кучи. Она находит наибольший элемент среди корня i и его потомков left = 2*i + 1 и right = 2*i + 2. Если наибольший элемент - не корень, то swap(arr[i], arr[largest]) меняет их местами, и рекурсивный вызов heapify(arr, n, largest) продолжает процедуру для затронутого поддерева. В heapSort первый цикл for (int i = n/2 - 1; ...) строит max-кучу, вызывая heapify для всех нелистовых узлов снизу вверх. Второй цикл for (int i = n-1; ...) извлекает элементы: swap(arr[0], arr[i]) перемещает максимальный элемент (корень) в конец массива, затем heapify(arr, i, 0) восстанавливает свойства кучи для уменьшенного массива.

Пример:

Исходный массив: [4, 10, 3, 5, 1]
Результат: [1, 3, 4, 5, 10]

Сложность: Сложность всегда O(n log n), так как построение кучи занимает O(n), а каждое из n извлечений максимума требует O(log n) времени.

8. Последовательный поиск

Определение: Самый простой алгоритм поиска, который проверяет каждый элемент коллекции последовательно, пока не найдет целевой элемент или не проверит все элементы.

Как работает: Алгоритм начинает с первого элемента массива и последовательно сравнивает каждый элемент с искомым значением. Если элемент найден, возвращается его индекс. Если после проверки всех элементов совпадение не найдено, возвращается специальное значение (обычно -1).

Пример:

Массив: ["яблоко", "банан", "апельсин", "виноград"]
Результат: Элемент найден на позиции 2 (индекс начинается с 0).

Сложность: O(n), так как в худшем случае (элемента нет или он последний) необходимо проверить все n элементов.

9. Бинарный поиск

Определение: Эффективный алгоритм для поиска в отсортированном массиве. На каждом шаге он сравнивает искомый элемент с элементом в середине диапазона и отбрасывает одну из половин, в которой заведомо нет искомого элемента.

Как работает: Поиск начинается с всего массива. Определяется средний элемент. Если целевое значение равно среднему элементу — поиск завершен. Если целевое значение меньше, поиск продолжается в левой половине. Если больше — в правой. Процесс повторяется для выбранной половины.

Пример:

Отсортированный массив: [2, 3, 5, 7, 11, 13, 17, 19]
Результат: Индекс 4.

Сложность: O(log n), так как на каждом шаге область поиска сокращается вдвое.

10. Интерполирующий поиск

Определение: Улучшенный алгоритм поиска в отсортированном массиве, который использует значения элементов для предсказания вероятного положения искомого элемента. Особенно эффективен на равномерно распределенных данных.

Как работает: Вместо деления массива пополам, как в бинарном поиске, этот алгоритм вычисляет позицию по формуле, аналогичной интерполяции. Предполагается, что элементы в массиве равномерно распределены между минимальным и максимальным значениями.

Пример:

Массив: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] (равномерное распределение)
Результат: Индекс 5.

Сложность: В среднем O(log log n) для равномерно распределенных данных, что быстрее бинарного поиска. В худшем случае (сильно неравномерное распределение) может деградировать до O(n).

11. Поиск Фибоначчи

Определение: Алгоритм, который делит массив с помощью чисел Фибоначчи. Он использует числа Фибоначчи для определения точек сравнения и сужения области поиска.

Как работает: Алгоритм находит наименьшее число Фибоначчи, которое больше или равно размеру массива. Затем он использует два предыдущих числа Фибоначчи для определения точек сравнения. В зависимости от результата сравнения область поиска сужается, и числа Фибоначчи пересчитываются.

Пример:

Отсортированный массив: [1, 3, 5, 7, 9, 11, 13, 15]
Результат: Индекс 3.

Сложность: O(log n), аналогично бинарному поиску, но может работать немного эффективнее на некоторых системах из-за использования только операций сложения и вычитания вместо деления.
