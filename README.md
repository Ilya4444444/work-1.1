Алгоритм Backtracking (поиск с возвратом) 

Объяснение алгоритма: 
1. Инициализация пустой доски - создаем доску N×N, заполненную точками (vector<string> board(n, string(n, '.'))).
2. Начало рекурсивного поиска - запускаем backtracking с первой строки (solve(board, 0, n)).
3. Проверка завершения - если дошли до последней строки, сохраняем решение (if (row == n) solutions.push_back(board)).
4. Перебор позиций в текущей строке - пробуем все столбцы для размещения ферзя (for (int col = 0; col < n; col++)).
5. Проверка безопасности позиции - убеждаемся, что ферзь не под атакой (if (isSafe(board, row, col, n))).
6. Размещение ферзя - ставим 'Q' в выбранную позицию (board[row][col] = 'Q').
7. Рекурсивный вызов для следующей строки - переходим к размещению следующего ферзя (solve(board, row + 1, n)).
8. Возврат (backtrack) - убираем ферзя, чтобы попробовать другую позицию (board[row][col] = '.').

Ввод: N = 8
Вывод: Количество решений для 8 ферзей: 92
Первое решение:
Q . . . . . . .
. . . . Q . . .
. . . . . . . Q
. . . . . Q . .
. . Q . . . . .
. . . . . . Q .
. Q . . . . . .
. . . Q . . . .

Временная сложность: O(N!) - алгоритм последовательно размещает ферзей на доске, где каждый следующий ферзь имеет на один вариант меньше из-за необходимости избегать атак, что приводит к факториальному росту количества проверяемых расстановок, и хотя оптимизации сокращают фактическое число проверок, асимптотическая сложность остается факториальной.
