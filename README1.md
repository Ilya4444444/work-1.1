Алгоритм Backtracking (поиск с возвратом) 

Вариант 13. Решите задачу о расстановке N ферзей для N = 8.

Объяснение алгоритма: 
1. Инициализация пустой доски - создаем доску N×N, заполненную точками (vector<string> board(n, string(n, '.'))).
2. Начало рекурсивного поиска - запускаем backtracking с первой строки (solve(board, 0, n)).
3. Проверка завершения - если дошли до последней строки, сохраняем решение (if (row == n) solutions.push_back(board)).
4. Перебор позиций в текущей строке - пробуем все столбцы для размещения ферзя (for (int col = 0; col < n; col++)).
5. Проверка безопасности позиции - убеждаемся, что ферзь не под атакой (if (isSafe(board, row, col, n))).
6. Размещение ферзя - ставим 'Q' в выбранную позицию (board[row][col] = 'Q').
7. Рекурсивный вызов для следующей строки - переходим к размещению следующего ферзя (solve(board, row + 1, n)).
8. Возврат (backtrack) - убираем ферзя, чтобы попробовать другую позицию (board[row][col] = '.').

Ввод: N = 8
Вывод: Количество решений для 8 ферзей: 92
Первое решение:
Q . . . . . . .
. . . . Q . . .
. . . . . . . Q
. . . . . Q . .
. . Q . . . . .
. . . . . . Q .
. Q . . . . . .
. . . Q . . . .

Временная сложность: O(N!) - алгоритм последовательно размещает ферзей на доске, где каждый следующий ферзь имеет на один вариант меньше из-за необходимости избегать атак, что приводит к факториальному росту количества проверяемых расстановок, и хотя оптимизации сокращают фактическое число проверок, асимптотическая сложность остается факториальной.

Ответ на вопрос: Мемоизация — это техника оптимизации, которая сохраняет результаты выполнения функций для избежания повторных вычислений. Когда функция вызывается с определенными аргументами, сначала проверяется, не вычислялся ли уже результат для этих параметров — если да, он возвращается из кэша, а если нет, производится вычисление с последующим сохранением результата. Это особенно эффективно для рекурсивных алгоритмов с перекрывающимися подзадачами, как в случае вычисления чисел Фибоначчи, где без мемоизации сложность составляет O(2^n), а с мемоизацией уменьшается до O(n) за счет устранения избыточных вычислений. Мемоизация преобразует дерево рекурсивных вызовов в направленный ациклический граф, где каждая уникальная подзадача вычисляется только один раз, что кардинально улучшает производительность, хотя и требует дополнительной памяти для хранения кэша результатов.
